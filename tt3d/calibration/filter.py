"""
Plot the data generated by calibrate.py
"""
import pandas as pd
from pathlib import Path
import numpy as np
import argparse
from utils import read_camcal, write_camera_info
import matplotlib.pyplot as plt
from pykalman import KalmanFilter
from scipy.spatial.transform import Rotation as R
from pykalman import KalmanFilter


def correct_flips(rvec):
    corrected_rvec = rvec.copy()
    for i in range(1, len(rvec)):
        # If a flip of approximately pi is detected, invert the vector
        if np.linalg.norm(corrected_rvec[i] + corrected_rvec[i - 1]) < np.linalg.norm(
            corrected_rvec[i] - corrected_rvec[i - 1]
        ):
            corrected_rvec[i] = (
                r.from_rotvec(corrected_rvec[i]) * r.from_rotvec([0, 0, np.pi])
            ).as_rotvec()
    return corrected_rvec


class KalmanFilterWithOutlierRejection:
    def __init__(self, n_dim=3, outlier_threshold=3.0, n_iter=10):
        """
        Kalman filter with simple Z-score outlier rejection.

        Args:
            n_dim (int): Dimensionality of input (1 or 3).
            outlier_threshold (float): Z-score threshold to reject outliers.
            n_iter (int): Number of EM iterations for fitting.
        """
        self.n_dim = n_dim
        self.outlier_threshold = outlier_threshold
        self.n_iter = n_iter
        self.kf = KalmanFilter(
            transition_matrices=np.eye(self.n_dim),
            observation_matrices=np.eye(self.n_dim),
            n_dim_obs=self.n_dim,
            n_dim_state=self.n_dim,
        )

    def fit(self, data: np.ndarray) -> np.ndarray:
        """
        Fit the Kalman filter and reject outliers.

        Args:
            data (np.ndarray): Input data of shape (n, n_dim).

        Returns:
            np.ndarray: Filtered data of same shape.
        """
        data = np.asarray(data).reshape((-1, self.n_dim))
        assert (
            data.ndim == 2 and data.shape[1] == self.n_dim
        ), f"Expected data shape (n, {self.n_dim}), got {data.shape}"

        # Step 1: Fit EM to all data
        self.kf = self.kf.em(data, n_iter=self.n_iter)
        smoothed, _ = self.kf.smooth(data)

        # Step 2: Compute Z-score between observed and smoothed
        residual = data - smoothed
        std_dev = np.std(residual, axis=0) + 1e-6  # avoid div by zero
        z_score = np.abs(residual / std_dev)

        # Step 3: Reject outliers (mark as NaN)
        outlier_mask = np.any(z_score > self.outlier_threshold, axis=1)
        data_clean = np.copy(data)
        data_clean[outlier_mask] = np.nan

        # Step 4: Interpolate missing values (optional)
        for d in range(self.n_dim):
            col = data_clean[:, d]
            if np.any(np.isnan(col)):
                not_nan = ~np.isnan(col)
                col[np.isnan(col)] = np.interp(
                    np.flatnonzero(np.isnan(col)), np.flatnonzero(not_nan), col[not_nan]
                )
                data_clean[:, d] = col

        # Step 5: Final Kalman smoothing on cleaned data
        self.kf = self.kf.em(data_clean, n_iter=self.n_iter)
        filtered, _ = self.kf.smooth(data_clean)
        return filtered


def interquartile_mean(data):
    """
    Calculates the interquartile mean of a dataset.

    Parameters:
        data (array-like): An n x 1 or n x 3 array of numerical values.

    Returns:
        float or np.ndarray: The interquartile mean(s) of the data.
                             Returns a float for n x 1 input and an array of size 3 for n x 3 input.
    """
    data = np.asarray(data)

    if data.ndim == 1 or (data.ndim == 2 and data.shape[1] == 1):
        # For n x 1 data, flatten to a 1D array
        data = data.flatten()
        q1, q3 = np.percentile(data, [25, 75])
        iq_data = data[(data >= q1) & (data <= q3)]
        return np.mean(iq_data)

    elif data.ndim == 2 and data.shape[1] == 3:
        # For n x 3 data, compute the interquartile mean for each column separately
        iq_means = []
        for i in range(3):
            column = data[:, i]
            q1, q3 = np.percentile(column, [35, 65])
            iq_data = column[(column >= q1) & (column <= q3)]
            iq_means.append(np.mean(iq_data))
        return np.array(iq_means)

    else:
        raise ValueError("Input must be of shape (n, 1) or (n, 3).")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("calib_csv")
    parser.add_argument("-o", "--output", help="Path for the csv")
    parser.add_argument("-w", "--width", help="Video width")
    parser.add_argument("-he", "--height", help="Video height")
    parser.add_argument(
        "--display",
        help="Display the generated segmentation frames",
        action="store_true",
    )
    parser.add_argument(
        "--so",
        help="Outputs one single camera calibration",
        action="store_true",
    )

    args = parser.parse_args()
    print("Calibration file: ", args.calib_csv)
    input_path = Path(args.calib_csv)

    idxs, rvecs, tvecs, fs = read_camcal(input_path)
    print(idxs.shape)
    print(rvecs.shape)

    rvec_kf = KalmanFilterWithOutlierRejection(n_dim=3)
    f_rvecs = rvec_kf.fit(rvecs)
    tvec_kf = KalmanFilterWithOutlierRejection(n_dim=3)
    f_tvecs = tvec_kf.fit(tvecs)
    f_kf = KalmanFilterWithOutlierRejection(n_dim=1)
    f_f = f_kf.fit(fs)

    if args.so:
        output_path = input_path.parent / "camera.yaml"
        m_f = interquartile_mean(f_f)
        m_rvec = interquartile_mean(f_rvecs)
        m_tvec = interquartile_mean(f_tvecs)
        print("Mean rvec:", m_rvec)
        print("Mean tvec:", m_tvec)
        print("Mean f:", m_f)
        write_camera_info(output_path, m_rvec, m_tvec, m_f, args.height, args.width)

    if args.display:
        # Plot settings
        colors = {"X": "red", "Y": "green", "Z": "blue"}
        fig, axs = plt.subplots(3, 1, figsize=(10, 8))

        # Plot focal length
        axs[0].scatter(
            idxs,
            fs,
            label="f",
            color="purple",
            marker="+",
            alpha=0.5,
        )
        axs[0].plot(
            idxs,
            f_f,
            label="f (filtered)",
            color="purple",
            linestyle="-",
        )
        # axs[0].xlabel("Frame")
        axs[0].set_ylabel("f")
        # axs[0].title("Focal Length Across Frames")
        axs[0].grid(True)
        axs[0].xaxis.set_ticklabels([])

        # Plot Rvec
        axs[1].scatter(
            idxs,
            rvecs[:, 0],
            label="Rvec_X (raw)",
            color=colors["X"],
            marker="+",
            alpha=0.5,
        )
        axs[1].scatter(
            idxs,
            rvecs[:, 1],
            label="Rvec_Y (raw)",
            color=colors["Y"],
            marker="+",
            alpha=0.5,
        )
        axs[1].scatter(
            idxs,
            rvecs[:, 2],
            label="Rvec_Z (raw)",
            color=colors["Z"],
            marker="+",
            alpha=0.5,
        )
        axs[1].plot(
            idxs,
            f_rvecs[:, 0],
            label="Rvec_X (filtered)",
            color="darkred",
            linestyle="-",
        )
        axs[1].plot(
            idxs,
            f_rvecs[:, 1],
            label="Rvec_Y (filtered)",
            color="darkgreen",
            linestyle="-",
        )
        axs[1].plot(
            idxs,
            f_rvecs[:, 2],
            label="Rvec_Z (filtered)",
            color="darkblue",
            linestyle="-",
        )
        # axs[1].xlabel("Frame")
        axs[1].set_ylabel("Rvec [rad]")
        # axs[1].title("Rotation Vector (Rvec) Across Frames")
        axs[1].grid(True)
        axs[1].xaxis.set_ticklabels([])

        # Plot Tvec
        axs[2].scatter(
            idxs,
            tvecs[:, 0],
            label="X",
            color=colors["X"],
            marker="+",
            alpha=0.5,
        )
        axs[2].scatter(
            idxs,
            tvecs[:, 1],
            label="Y",
            color=colors["Y"],
            marker="+",
            alpha=0.5,
        )
        axs[2].scatter(
            idxs,
            tvecs[:, 2],
            label="Z",
            color=colors["Z"],
            marker="+",
            alpha=0.5,
        )
        axs[2].plot(
            idxs,
            f_tvecs[:, 0],
            label="_nolegend_",
            color="darkred",
            linestyle="-",
        )
        axs[2].plot(
            idxs,
            f_tvecs[:, 1],
            label="_nolegend_",
            color="darkgreen",
            linestyle="-",
        )
        axs[2].plot(
            idxs,
            f_tvecs[:, 2],
            label="_nolegend_",
            color="darkblue",
            linestyle="-",
        )
        axs[2].set_xlabel("Frame")
        axs[2].set_ylabel("Tvec [m]")
        # axs[2].title("Translation Vector (Tvec) Across Frames")
        axs[2].grid(True)

        # Adjust the axis position to make room for the legend
        box = axs[2].get_position()
        axs[2].set_position(
            [box.x0, box.y0 + box.height * 0.15, box.width, box.height * 0.85]
        )

        # Place the legend below the plot, ensuring it does not overlap
        axs[2].legend(
            loc="lower right",
            bbox_to_anchor=(0.4, -0.6),  # Adjust the vertical offset
            fancybox=True,
            shadow=True,
            ncol=3,
        )

        # Adjust layout to prevent overlap between the legend and the x-axis label
        plt.tight_layout()  # Adjust the bottom margin to fit the legend
        plt.show()
